C51 COMPILER V9.54   LT8910                                                                10/15/2018 00:12:04 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE LT8910
OBJECT MODULE PLACED IN LT8910.OBJ
COMPILER INVOKED BY: E:\KeilC51\C51\BIN\C51.EXE LT8910.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //#include <STC15W4K48S4.h>     //STC15W4K48S4 单片机头文件
   2          #include "LT8910.h"                     //无线2.4G模块
   3          uchar RegH;
   4          uchar RegL;
   5          
   6          /*LT8910端口定义*/
   7          sbit RST_LT8910 = P1 ^ 2; //当RST_n 为高时，将开启芯片，寄存器将回复复位值
   8          sbit SPI_ENA_LT8910 = P1 ^ 1; //使能SPI 信号，低电平有效，也可以使芯片进入sleep mode
   9          sbit SPI_CLK_LT8910 = P1 ^ 5; //SPI/I2C 时钟输入脚
  10          sbit MOSI_LT8910 = P1 ^ 3; //data 输入脚
  11          sbit MISO_LT8910 = P1 ^ 4; //data 输出脚
  12          sbit PKT_LT8910 = P3 ^ 2; //发射/接收状态标志位 可通过设置为高或低有效
  13          
  14          /**
  15           * us级延时函数
  16           *
  17           * @author KingBoy (2018/5/20)
  18           *
  19           * @param n us
  20           */
  21          void Delay_us(uint n)
  22          {
  23   1              for (; n > 0; n--);
  24   1      }
  25          /**
  26           * 写寄存器。spi使能（拉低），data脚由高位至低位传送地址和数据
  27           * 即1字节地址，1字节高8位数据，1字节低8位数据，spi使能关闭（拉高）
  28           * 下降沿采样
  29           *
  30           * @author KingBoy (2018/5/20)
  31           *
  32           * @param addr 写入的地址
  33           * @param H 高字节
  34           * @param L 低字节
  35           */
  36          void SPI_WriteReg(uchar addr, uchar H, uchar L)
  37          {
  38   1              int i;
  39   1              SPI_ENA_LT8910 = 0;
  40   1              for (i = 0; i < 8; ++i)
  41   1              {
  42   2                      MOSI_LT8910 = addr & 0x80;
  43   2                      SPI_CLK_LT8910 = 1;
  44   2                      SPI_CLK_LT8910 = 0;
  45   2                      addr = addr << 1;
  46   2              }
  47   1              for (i = 0; i < 8; ++i)
  48   1              {
  49   2                      MOSI_LT8910 = H & 0x80;
  50   2                      SPI_CLK_LT8910 = 1;
  51   2                      SPI_CLK_LT8910 = 0;
  52   2                      H = H << 1;
  53   2              }
  54   1              for (i = 0; i < 8; ++i)
  55   1              {
C51 COMPILER V9.54   LT8910                                                                10/15/2018 00:12:04 PAGE 2   

  56   2                      MOSI_LT8910 = L & 0x80;
  57   2                      SPI_CLK_LT8910 = 1;
  58   2                      SPI_CLK_LT8910 = 0;
  59   2                      L = L << 1;
  60   2              }
  61   1              SPI_ENA_LT8910 = 1;
  62   1      }
  63          /**
  64           * 读寄存器。spi使能（拉低），data脚由高位至低位传送地址
  65           * 先读高字节，由低至高8位，再读低字节，由低至高8位，spi使能关闭（拉高）
  66           * 下降沿采样
  67           *
  68           * @author KingBoy (2018/5/20)
  69           *
  70           * @param addr 要读取的地址
  71           */
  72          void SPI_ReadReg(uchar addr)
  73          {
  74   1              int i;
  75   1              SPI_ENA_LT8910 = 0;
  76   1              addr += 0x80;
  77   1              for (i = 0; i < 8; ++i)
  78   1              {
  79   2                      MOSI_LT8910 = addr & 0x80;
  80   2                      SPI_CLK_LT8910 = 1;
  81   2                      SPI_CLK_LT8910 = 0;
  82   2                      addr = addr << 1;
  83   2              }
  84   1              for (i = 0; i < 8; ++i)
  85   1              {
  86   2                      SPI_CLK_LT8910 = 1;
  87   2                      SPI_CLK_LT8910 = 0;
  88   2                      RegH = RegH << 1;
  89   2                      RegH |= MISO_LT8910;
  90   2              }
  91   1              for (i = 0; i < 8; ++i)
  92   1              {
  93   2                      SPI_CLK_LT8910 = 1;
  94   2                      SPI_CLK_LT8910 = 0;
  95   2                      RegL = RegL << 1;
  96   2                      RegL |= MISO_LT8910;
  97   2              }
  98   1              SPI_ENA_LT8910 = 1;
  99   1      }
 100          /**
 101           * LT8910初始化
 102           *
 103           * @author KingBoy (2018/5/20)
 104           *
 105           * @param void
 106           */
 107          void LT8910_Init(void)
 108          {
 109   1              RST_LT8910 = 0;       //复位 拉低
 110   1              Delay_us(500); //延时 500微秒
 111   1              RST_LT8910 = 1;       //复位 拉高
 112   1              Delay_us(500); //延时 500微秒
 113   1              PKT_LT8910 = 1;       //收发 标志位 拉高
 114   1              SPI_WriteReg(0, 0x6f, 0xef);  //
 115   1              SPI_WriteReg(1, 0x56, 0x81);  //
 116   1              SPI_WriteReg(2, 0x66, 0x17);  //
 117   1              SPI_WriteReg(4, 0x9c, 0xc9);  //
C51 COMPILER V9.54   LT8910                                                                10/15/2018 00:12:04 PAGE 3   

 118   1              SPI_WriteReg(5, 0x66, 0x37);  //
 119   1              SPI_WriteReg(7, 0x00, 0x00);  //设定RF 频道，空中频率为：f=2402+ RF_PLL_CH_NO
 120   1              SPI_WriteReg(8, 0x6c, 0x90);  //
 121   1              SPI_WriteReg(9, 0x48, 0x00);  //PA 增益控制 -12.2dbm
 122   1              SPI_WriteReg(10, 0x7f, 0xfd);  //晶体振荡器
 123   1              SPI_WriteReg(11, 0x00, 0x08);  //RSSI
 124   1              SPI_WriteReg(12, 0x00, 0x00);  //校准VCO
 125   1              SPI_WriteReg(13, 0x48, 0xbd);  //
 126   1              SPI_WriteReg(22, 0x00, 0xff);  //
 127   1              SPI_WriteReg(23, 0x80, 0x05);  //
 128   1              SPI_WriteReg(24, 0x00, 0x67);  //
 129   1              SPI_WriteReg(25, 0x16, 0x59);  //
 130   1              SPI_WriteReg(26, 0x19, 0xe0);  //
 131   1              SPI_WriteReg(27, 0x13, 0x00);  //
 132   1              SPI_WriteReg(28, 0x18, 0x00);  //
 133   1              SPI_WriteReg(32, 0x58, 0x00);  //LEN(重要参数)
 134   1              SPI_WriteReg(33, 0x3f, 0xc7);  //
 135   1              SPI_WriteReg(34, 0x20, 0x00);  //
 136   1              SPI_WriteReg(35, 0x0a, 0x00);  //重发次数为9次 一共发送10次
 137   1              SPI_WriteReg(36, 0x00, 0x01);  //SYNC_WORD[15:0]
 138   1              SPI_WriteReg(37, 0x00, 0x01);  //SYNC_WORD[31:16]
 139   1              SPI_WriteReg(38, 0x00, 0x01);  //SYNC_WORD[47:32]
 140   1              SPI_WriteReg(39, 0x00, 0x01);  //SYNC_WORD[63:48]
 141   1              SPI_WriteReg(40, 0x44, 0x02);  //FIFO 阈值
 142   1              SPI_WriteReg(41, 0xb8, 0x00);  //CRC=ON;scramble=OFF;AUTO_ACK=ON
 143   1              SPI_WriteReg(42, 0xfd, 0xff);  //RSSI 扫描的信道数量
 144   1              SPI_WriteReg(43, 0x00, 0x0f);  //开始扫描RSSI
 145   1                                                                         //SPI_WriteReg(44, 0x10, 0x00);  //
 146   1                                                                         //SPI_WriteReg(45, 0x05, 0x52);  //
 147   1      }
 148          /**
 149           * 2.4G无线模块LT8910设置为接收模式
 150           * 便宜货
 151           *
 152           * @author KingBoy (2018/5/20)
 153           *
 154           * @param void
 155           */
 156          void RX_model(void)
 157          {
 158   1              SPI_WriteReg(52, 0x80, 0x80); //清空RX FIFO,TX FIFO
 159   1              SPI_WriteReg(7, 0x00, 0x80 + 0x20); //RX状态，freq2434
 160   1              Delay_us(200);
 161   1      }
 162          
 163          /**
 164           * 接收数据
 165           *
 166           * @author KingBoy (2018/5/20)
 167           *
 168           * @param rx_buf 接收缓存
 169           * @param Num 数据个数(ushort?)
 170           */
 171          void ReceiveRC_Data(uchar *rx_buf, uchar Num)
 172          {
 173   1              uchar i = 0;
 174   1              SPI_ReadReg(50);
 175   1              if (RegH == Num && RegL == 0)
 176   1              {
 177   2                      while (i < Num)
 178   2                      {
 179   3                              SPI_ReadReg(50);
C51 COMPILER V9.54   LT8910                                                                10/15/2018 00:12:04 PAGE 4   

 180   3                              rx_buf[i++] = RegH;
 181   3                              rx_buf[i++] = RegL;
 182   3                      }
 183   2              }
 184   1      }
 185          /**
 186           * 通讯校验函数
 187           *
 188           * @author KingBoy (2018/10/8)
 189           *
 190           * @param buf 待计算校验的数组
 191           * @param len 待计算校验的数组长度
 192           * @param mac 需要比对的校验值
 193           *
 194           * @return int 0 为一致，非0为计算的校验结果
 195           */
 196          int MAC_calc(unsigned char * buff,int len, unsigned char mac)
 197          {
 198   1              int i = 0;
 199   1              unsigned char mac_calc = 0;
 200   1              for (i = 0;i<len;i++)
 201   1              {
 202   2                      mac_calc+=(*buff++);
 203   2              }
 204   1              if (mac == mac_calc)
 205   1              {
 206   2                      return 0;
 207   2              }
 208   1              else
 209   1              {
 210   2                      if (mac_calc !=0)
 211   2                      {
 212   3                              return ((int)mac_calc);
 213   3                      }
 214   2                      else
 215   2                      {
 216   3                              return -1;
 217   3                      }
 218   2              }
 219   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    721    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
