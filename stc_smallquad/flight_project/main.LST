C51 COMPILER V9.54   MAIN                                                                  10/11/2018 00:05:16 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\KeilC51\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15W4K60S4.h>       //STC15W4K48S4 专用头文件
   2          #include <intrins.h>            //STC特殊命令符号声明
   3          #include <MPU-6050.H>           //MPU6050数字陀螺仪
   4          #include <STC15W4K-PWM.H>       //单片机所有IO口初始化-PWM口初始化
   5          #include <LT8910.h>                     //无线2.4G模块
   6          //#include <STC15W4K-ADC.h>     //STC15W4K-ADC  硬件ADC模数转换
   7          #include <IMU.H>                        //IMU飞行核心算法
   8          #include <KalmanFilter.h>  //卡尔曼滤波算法
   9          #include "globeVar.h"
  10          #include "alldef.h"
  11          #include "FlightControl.h"
  12          
  13          bit busy;
  14          
  15          /**
  16           * 定时器0 初始化函数
  17           * 12毫秒@24.000MHz
  18           *
  19           * @author KingBoy (2018/5/19)
  20           *
  21           * @param void
  22           */
  23          void TimerInit(void);
  24          /**
  25           * 时间延时 函数
  26           *
  27           * @author KingBoy (2018/5/20)
  28           *
  29           * @param x
  30           */
  31          void Delay(unsigned int x);
  32          /*----------------------------
  33          发送串口数据
  34          ----------------------------*/
  35          void SendData(BYTE dat)
  36          {
  37   1              while (busy); //等待前面的数据发送完成
  38   1              ACC = dat; //获取校验位P (PSW.0)
  39   1              busy = 1;
  40   1              SBUF = ACC; //写数据到UART数据寄存器
  41   1      }
  42          
  43          /*----------------------------
  44          发送字符串
  45          ----------------------------*/
  46          void SendString(char *s)
  47          {
  48   1              while (*s) //检测字符串结束标志
  49   1              {
  50   2                      SendData(*s++); //发送当前字符
  51   2              }
  52   1      } 
  53          
  54          void UartInit(void)
  55          {
C51 COMPILER V9.54   MAIN                                                                  10/11/2018 00:05:16 PAGE 2   

  56   1              SCON = 0x50; //8位可变波特率
  57   1              T2L = (65536 - (FOSC / 4 / BAUD));
  58   1              T2H = (65536 - (FOSC / 4 / BAUD)) >> 8;
  59   1              AUXR |= 0X14;
  60   1              AUXR |= 0X01;
  61   1      
  62   1      }
  63          
  64          /**
  65           * 单片机采用STC15W4K48S4-增强型单片机（IPA需修改EEPROM代码）
  66           * 工作电压为：5V 晶振频率为：24M 无线通讯模块为：LT8910
  67           * 本程序中采用了MCU6050做姿态数据采集加PID算法给硬件4路PWM控制MOS管驱动空心杯电机
  68           * 注意：此程序只兼容：空心杯716电机与45MM专用正反桨（自己的电机或需修改PID参数）
  69           * 在后期的程序更新中，会增加硬件代码达到预期飞行功能。敬请关注。
  70           *
  71           * @author KingBoy (2018/5/19)
  72           *
  73           * @param void
  74           */
  75          void main(void)
  76          {
  77   1              PWM_Init(); //初始化PWM
  78   1              Set_PWM(1000, 1000, 1000, 1000); //关闭电机
  79   1              LedR = 0;
  80   1              LedG = 1;
  81   1              LedB = 1; //3颗状态灯
  82   1              Delay(500); //延时一会
  83   1              LedR = 1;
  84   1              LedG = 0;
  85   1              LedB = 1; //3颗状态灯
  86   1              Delay(500); //延时一会
  87   1              LedR = 1;
  88   1              LedG = 1;
  89   1              LedB = 0; //3颗状态灯
  90   1              Delay(500); //延时一会
  91   1              LedR = 1;
  92   1              LedG = 1;
  93   1              LedB = 1; //3颗状态灯
  94   1              Delay(10);    // 延时 100
  95   1      
  96   1              //InitADC();/ADC模数转换 初始化（后期开发）
  97   1              Delay(10); //延时 100
  98   1              Init_MPU6050(); //初始化MPU-6050
  99   1              Delay(10); //延时 100
 100   1              LT8910_Init(); //无线2.4G模块初始化
 101   1              Delay(100); //延时一会 1S
 102   1      
 103   1              TimerInit(); //初始化定时器
 104   1              Delay(100);   //延时一会 1S
 105   1              /*默认值初始化*/
 106   1              UartInit(); //初始化串口
 107   1              rc_throttle = 0;   //初始化油门变量
 108   1              rc_Yaw = 128;      //初始化航向变量
 109   1              rc_Roll = 128;     //初始化横滚变量
 110   1              rc_Pitch = 128;    //初始化俯仰变量
 111   1              LedB = 0;       //开启绿灯
 112   1              rcAngle_X_offset = 0;        //横滚手动值
 113   1              rcAngle_Y_offset = 0;        //俯仰手动值
 114   1              rcAngle_Z_offset = 0;        //航向手动值
 115   1      
 116   1              //Flight();//编译后2个警告是说 飞控函数中断量 不在主函数里【不需要纠结】
 117   1              ES = 1; //使能串口1中断
C51 COMPILER V9.54   MAIN                                                                  10/11/2018 00:05:16 PAGE 3   

 118   1              EA = 1;  //开总中断
 119   1              while (1)
 120   1              {
 121   2      #if 0
                              //要放到定时器中断里运行
                              RX_model();             //接收模式
                              js_shuju(RxBuf, 15);     //读取数据包
              #endif
 126   2                      SendString("STC15F2K60S2\r\nUart Test !\r\n");
 127   2                      /*控制指令接收正确*/
 128   2                      if (MAC_calc(RxBuf, 10, RxBuf[10]) == 0)
 129   2                      {
 130   3                              LostCom = RxBuf[0];                         //接收 失联变量
 131   3                              LockState = RxBuf[1];                       //接收 命令值 1=上锁  5=解锁
 132   3                              rc_throttle = RxBuf[2] * 0xff + RxBuf[3];   //接收 油门变量
 133   3                              rc_Yaw = RxBuf[4];                          //接收 航向摇杆参数
 134   3                              rc_Roll = RxBuf[5];                         //接收 横滚摇杆参数
 135   3                              rc_Pitch = RxBuf[6];                        //接收 俯仰摇杆参数
 136   3                              rcAngle_X_offset = RxBuf[7] - 128;          //读出 横滚微调变量
 137   3                              rcAngle_Y_offset = RxBuf[8] - 128;          //读出 俯仰微调变量
 138   3                              rcAngle_Z_offset = RxBuf[9] - 128;          //读出 航向微调变量
 139   3                              LedG = 1;                                   //LED 绿灯灭
 140   3                      }
 141   2                      else
 142   2                      {
 143   3                              LedG = 0;                               //LED 绿灯亮
 144   3                      }
 145   2                      if (LockState == 1)                         //遥控命令 上锁
 146   2                      {
 147   3                              LedB = 1;                               //航向灯 蓝色灭
 148   3                      }
 149   2                      if (LockState == 5)                         //遥控命令 解锁
 150   2                      {
 151   3                              LedB = 0;                               //航向灯 蓝色亮
 152   3                      }
 153   2                      Delay(3);     //延时一会
 154   2      #if 0
                              //ADC电压低压检测自停保护功能 后期开发
                              ADC_CONTR
              #endif
 158   2                      //UartPrint();
 159   2              }
 160   1      }
 161          
 162          /**
 163           * 定时器0 初始化函数
 164           * 12毫秒@24.000MHz
 165           *
 166           * @author KingBoy (2018/5/19)
 167           *
 168           * @param void
 169           */
 170          void TimerInit(void)
 171          {
 172   1              AUXR &= 0x7F;   //定时器时钟12T模式
 173   1              TMOD &= 0xF0;   //设置定时器模式
 174   1              TL0 = 0x40;     //设置定时初值
 175   1              TH0 = 0xA2;     //设置定时初值
 176   1              TF0 = 0;        //清除TF0标志
 177   1              TR0 = 1;        //定时器0开始计时
 178   1              ET0 = 1;        //Timer0 Interrupt Enable
 179   1      }
C51 COMPILER V9.54   MAIN                                                                  10/11/2018 00:05:16 PAGE 4   

 180          /**
 181           * 时间延时 函数
 182           *
 183           * @author KingBoy (2018/5/20)
 184           *
 185           * @param x
 186           */
 187          void Delay(unsigned int x)
 188          {
 189   1              unsigned int i, j;
 190   1              for (i = 0; i < x; i++)
 191   1              {
 192   2                      for (j = 0; j < 250; j++)
 193   2                      {
 194   3                              ;
 195   3                      }
 196   2              }
 197   1      }
 198          
 199          /**
 200           * PID算法飞控自平衡函数，定时器0中断12毫秒执行一次
 201           *
 202           * @author KingBoy (2018/5/20)
 203           *
 204           * @param void
 205           */
 206          void Flight(void) interrupt 1
 207          {
 208   1              /*LT8910设置为接收模式*/
 209   1              RX_model();
 210   1              /*接收15字节数据*/
 211   1              ReceiveData(RxBuf, 15);
 212   1      
 213   1      
 214   1              Read_MPU6050(IMUdata); //直接读取MPU6050陀螺仪和加速度的数据包
 215   1      
 216   1              Angle_ax = RCLowPassFilter_ax(((int *)&IMUdata)[0], RC_KALMAN_Q, RC_KALMAN_R);  //低通滤波，见文档解释
 217   1              Angle_ay = RCLowPassFilter_ay(((int *)&IMUdata)[1], RC_KALMAN_Q, RC_KALMAN_R);
 218   1              Angle_az = RCLowPassFilter_az(((int *)&IMUdata)[2], RC_KALMAN_Q, RC_KALMAN_R);
 219   1      
 220   1              Omega_gx = ((float)(((int *)&IMUdata)[4])) / 65.5;   //陀螺仪处理       结果单位是 +-度
 221   1              Omega_gy = ((float)(((int *)&IMUdata)[5])) / 65.5;   //陀螺仪量程 +-500度/S, 1度/秒 对应读数 65.536
 222   1              Omega_gz = RCLowPassFilter_gyroz(((int *)&IMUdata)[6], Q15(0.2), Q15(0.8));
 223   1              IMU_gz = Omega_gz / 65.5;
 224   1              Last_Angle_gx = Omega_gx;       //储存上一次角速度数据
 225   1              Last_Omega_gy = Omega_gy;
 226   1      
 227   1              //*********************************** 四元数解算 ***********************************
 228   1              IMUupdate(Omega_gx * 0.0174533f, Omega_gy * 0.0174533f, IMU_gz * 0.0174533f, Angle_ax, Angle_ay, Angle_az
             -);
 229   1              //姿态解算，精度0.1度
 230   1              //发送到遥控器
 231   1              //      TxBuf[0]=(AngleX+900)/0xff; // 数值是 48~1752 = 0-360度
 232   1              //      TxBuf[1]=(AngleX+900)%0xff;     // 数值是 48~1752 = 0-360度
 233   1              //      TxBuf[2]=(AngleY+900)/0xff;     // 数值是 48~1752 = 0-360度
 234   1              //      TxBuf[3]=(AngleY+900)%0xff;     // 数值是 48~1752 = 0-360度
 235   1              //****飞控失联判断 自动降落算法*********************
 236   1              //接收遥控器发来的不断更新数据 判断联机通讯是否正常
 237   1              LostControlProtect();
 238   1              /*姿态角失控保护*/
 239   1              DangerMotionProtect();
 240   1      
C51 COMPILER V9.54   MAIN                                                                  10/11/2018 00:05:16 PAGE 5   

 241   1              //****以下是飞行控制算法************************************
 242   1              PIDcontrolX();
 243   1              PIDcontrolY();
 244   1              PIDcontrolZ();
 245   1              //**************将速度参数加载至PWM模块*************************************************
 246   1              //速度参数控制，防止超过PWM参数范围0-1000（X型有效）
 247   1              PWMoutput();
 248   1      
 249   1              //满足条件：（解锁：2.4G=5；油门大于30）才能控制电机
 250   1              if (LockState == 5 && d_throttle >= 50)
 251   1              {
 252   2                      Set_PWM(1000 - PWM1, 1000 - PWM2, 1000 - PWM3, 1000 - PWM0);
 253   2              } //启动PWM
 254   1              else
 255   1              {
 256   2                      Set_PWM(1000, 1000, 1000, 1000);
 257   2              } //关闭PWM
 258   1      
 259   1      #if 1
 260   1              //调试强行关闭电机
 261   1              Set_PWM(1000, 1000, 1000, 1000);
 262   1      #endif
 263   1      }
 264          
 265          void Uart(void) interrupt 4 using 1
 266          {
 267   1              if(RI)
 268   1              {
 269   2                      RI = 0;
 270   2                      P0 = SBUF;
 271   2                      P22 = RB8;
 272   2              }
 273   1              if(TI)
 274   1              {
 275   2                      TI = 0;
 276   2                      busy = 0;
 277   2              }
 278   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1063    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
