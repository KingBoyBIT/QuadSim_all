C51 COMPILER V9.54   IMU                                                                   10/09/2018 19:57:35 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE IMU
OBJECT MODULE PLACED IN IMU.OBJ
COMPILER INVOKED BY: E:\KeilC51\C51\BIN\C51.EXE IMU.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15W4K48S4.h>       //STC15W4K48S4 专用头文件
   2          #include <math.H>
   3          #include "IMU.H"
   4          #include "alldef.h"
   5          
   6          
   7          float idata q0 = 1, q1 = 0, q2 = 0, q3 = 0;
   8          float idata exInt = 0, eyInt = 0, ezInt = 0;
   9          float idata exDif = 0, eyDif = 0, ezDif = 0;
  10          
  11          /**
  12           * IMU更新函数
  13           *
  14           * @author KingBoy (2018/5/20)
  15           *
  16           * @param gx 陀螺x
  17           * @param gy 陀螺y
  18           * @param gz 陀螺z
  19           * @param ax 加速度计x
  20           * @param ay 加速度计y
  21           * @param az 加速度计z
  22           */
  23          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az)
  24          {
  25   1              float idata norm;
  26   1              float idata vx, vy, vz;
  27   1              float idata ex, ey, ez;
  28   1              static float idata last_ex, last_ey, last_ez;
  29   1      
  30   1      #if 0
                      norm = sqrt(ax * ax + ay * ay + az * az); //把加速度计的三维向量转成单维向量
                      ax = ax / norm;
                      ay = ay / norm;
                      az = az / norm;
              #endif
  36   1              //使用快速计算，后续考虑避免乘除运算
  37   1              norm = invSqrt(ax * ax + ay * ay + az * az);
  38   1              ax = ax * norm;
  39   1              ay = ay * norm;
  40   1              az = az * norm;
  41   1      
  42   1              /*
  43   1      dcm(1,3,:) = 2.*(qin(:,2).*qin(:,4) - qin(:,1).*qin(:,3));
  44   1      dcm(2,3,:) = 2.*(qin(:,3).*qin(:,4) + qin(:,1).*qin(:,2));
  45   1      dcm(3,3,:) = qin(:,1).^2 - qin(:,2).^2 - qin(:,3).^2 + qin(:,4).^2;
  46   1               */
  47   1              //DCM的第三列
  48   1              vx = 2 * (q1 * q3 - q0 * q2);
  49   1              vy = 2 * (q0 * q1 + q2 * q3);
  50   1              vz = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;
  51   1      
  52   1              ex = (ay * vz - az * vy);
  53   1              ey = (az * vx - ax * vz);
  54   1              ez = (ax * vy - ay * vx);
  55   1      
C51 COMPILER V9.54   IMU                                                                   10/09/2018 19:57:35 PAGE 2   

  56   1              exInt = exInt + ex * NAV_PARA_EST_KI;
  57   1              eyInt = eyInt + ey * NAV_PARA_EST_KI;
  58   1              ezInt = ezInt + ez * NAV_PARA_EST_KI;
  59   1      
  60   1      
  61   1              exDif = ex - last_ex;
  62   1              eyDif = ey - last_ey;
  63   1              ezDif = ez - last_ez;
  64   1      
  65   1              last_ex = ex;
  66   1              last_ey = ey;
  67   1              last_ez = ez;
  68   1      
  69   1              gx = gx + NAV_PARA_EST_KP * ex + exInt + NAV_PARA_EST_KD * exDif;
  70   1              gy = gy + NAV_PARA_EST_KP * ey + eyInt + NAV_PARA_EST_KD * eyDif;
  71   1              gz = gz + NAV_PARA_EST_KP * ez + ezInt + NAV_PARA_EST_KD * ezDif;
  72   1      
  73   1      
  74   1              q0 = q0 + (-q1 * gx - q2 * gy - q3 * gz) * NAV_PARA_EST_HALF_T;
  75   1              q1 = q1 + (q0 * gx + q2 * gz - q3 * gy) * NAV_PARA_EST_HALF_T;
  76   1              q2 = q2 + (q0 * gy - q1 * gz + q3 * gx) * NAV_PARA_EST_HALF_T;
  77   1              q3 = q3 + (q0 * gz + q1 * gy - q2 * gx) * NAV_PARA_EST_HALF_T; 
  78   1      
  79   1      #if 0
                      norm = sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
                      q0 = q0 / norm;
                      q1 = q1 / norm;
                      q2 = q2 / norm;
                      q3 = q3 / norm;
              #endif
  86   1      
  87   1              //快速计算
  88   1              norm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
  89   1              q0 = q0 * norm;
  90   1              q1 = q1 * norm;
  91   1              q2 = q2 * norm;
  92   1              q3 = q3 * norm;
  93   1              AngleY = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2 * q2 + 1) * MATH_180_PI_10;
  94   1              AngleX = asin(2 * (q0 * q2 - q1 * q3)) * MATH_180_PI_10;
  95   1              //AngleZ = atan2(2 * q1 * q2 + 2 * q0 * q3, -2 * q2 * q2 - 2 * q3 * q3 + 1)* MATH_180_PI_10;
  96   1      
  97   1      }
  98          
  99          /**
 100           * 快速计算1/Sqrt(x)
 101           *
 102           * @author KingBoy (2018/5/20)
 103           *
 104           * @param x 输入x
 105           *
 106           * @return float 输出1/sqrt(x)
 107           */
 108          float invSqrt(float x)
 109          {
 110   1              float halfx = 0.5f * x;
 111   1              float y = x;
 112   1              long i = *(long *)&y;
 113   1              i = 0x5f3759df - (i >> 1);
 114   1              y = *(float *)&i;
 115   1              y = y * (1.5f - (halfx * y * y));
 116   1              return (y);
 117   1      }
C51 COMPILER V9.54   IMU                                                                   10/09/2018 19:57:35 PAGE 3   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2427    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     52      28
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
